---
description: 
globs: 
alwaysApply: true
---
---
description: BodyTD Implementation Rules and Development Process
globs: ["**/*.kt"]
alwaysApply: false
---

# BodyTD Implementation Rules

## 1. Development Philosophy

### 1.1 Incremental Development
- Build the game in small, testable increments
- Each increment should be a working version of the game
- Focus on one feature at a time
- Complete each feature before moving to the next

### 1.2 Refactoring Guidelines
- Refactor when:
  - Code duplication is detected
  - A class has too many responsibilities, or when an class feature could be modularized and expect further expansion
  - Code is hard to understand
- Refactor in small, focused steps

## 2. Implementation Order

### 2.1 Phase 1: Core Game Engine
1. **Basic Game Loop**
   - Implement GameManager singleton
   - Create basic game loop with fixed time step
   - Add simple rendering system

2. **Map and Path System**
   - Implement basic map representation
   - Create path system for enemies
   - Add validation for tower placement

3. **Basic UI Framework**
   - Set up Jetpack Compose structure
   - Implement basic HUD
   - Create placeholder for game view

### 2.2 Phase 2: Game Entities
1. **Enemy System**
   - Implement base Enemy class
   - Add basic enemy types (Virus, Bacteria, FineParticle)
   - Implement enemy movement along path

2. **Tower System**
   - Implement base Turret class
   - Create AttackStrategy interface
   - Implement basic tower types
   - Add tower targeting logic

3. **Player System**
   - Implement money management
   - Add tower placement logic

### 2.3 Phase 3: Game Mechanics
1. **Wave System**
   - Implement WaveManager
   - Create enemy spawning logic (Through EnemyFactory)

2. **Combat System**
   - Implement damage calculation

3. **Game State**
   - Add win/lose conditions: Win after 3rd wave. Lose if more than 3 enemies reach the end.

### 2.4 Phase 4: Polish and Optimization
1. **Visual Improvements**
   - Simple graphics, with static images

2. **User Experience**
   - Add sound effects

## 3. Code Organization

### 4.1 File Structure
- Keep related files together
- Use clear, descriptive names
- Follow package structure in specifications

### 4.2 Code Style
- Use consistent formatting
- Follow Kotlin idioms:
 1. Idiomatic Object-Oriented Design

    data class → Auto-generates boilerplate for value-based objects.

    object → Use for singletons, shared managers, or factories.

    interface + sealed class → Enforce controlled polymorphism and hierarchies.

 2. Idiomatic Architecture & Utility

    by lazy → Deferred and thread-safe initialization (for managers or configs).

    lateinit var → For mutable properties injected later (e.g., context-dependent instances).

    Extension Functions → Add utility to existing types (e.g., .dpToPx() on Int, or .isDead() on Enemy).

 3. Idiomatic Collections and Flow

    .filter, .map, .forEach, .associateBy, etc. → Write expressive and readable data logic.

    Destructuring (val (x, y) = position) → Simplify handling of compound objects like coordinates.

 4. Idiomatic State Management

    val uiState = remember { mutableStateOf(...) } → Compose-specific, for reactive UIs.

    sealed class + when → Elegant and exhaustive event or state handling.

 5. Idiomatic Communication & Events

    Use State, MutableStateFlow, or LiveData depending on architecture (Compose, MVVM, etc.).

    Implement Observer pattern using MutableState or Flow idiomatically.

    Use callbacks as lambdas for minimal coupling (onTowerPlaced: (Tower) -> Unit).

 6. Idiomatic Testing & Debugging

    Use when, require(), check() and error() to enforce assumptions early and catch issues faster.

    Favor pure functions for testable logic (especially in GameManager or Strategy classes).
- Check on the internet for the most recent coding practices/technologies each time you encounter a main problem that needs to be solved.

### 4.3 Documentation
- Analyze, compare and document design decisions in the broader picture/view

## 5. Interactive Development Process

### 5.1 Decision-Making Framework
1. **Problem Exploration**
   - AI identifies potential challenges and trade-offs
   - Presents multiple viable solutions
   - Analyzes pros and cons of each approach
   - Provides personal recommendation with reasoning
   - Developer (you) makes the final decision

2. **Key Decision Points**
   - Architecture choices
   - Design pattern selection
   - UI/UX approaches
   - Performance optimization strategies

### 5.2 Solution Discussion Format
1. **Problem Statement**
   - Clear description of the challenge
   - Impact on current codebase
   - Constraints and requirements

2. **Solution Options**
   - Minimum 2-3 different approaches
   - For each option:
     - Implementation details
     - Advantages
     - Disadvantages
     - Resource requirements
     - Future implications

3. **AI Recommendation**
   - Preferred solution with reasoning
   - Based on:
     - Current codebase state
     - Project requirements
     - Best practices
     - Performance considerations
     - Maintainability

4. **Developer Decision**
   - Final choice by you
   - AI adapts and proceeds based on your decision
   - Documents decision rationale for future reference

### 5.3 Collaboration Guidelines

1. **Communication Style**
   - Clear and concise explanations
   - Technical depth when needed
   - Visual diagrams for complex concepts
   - Logging for clarity

2. **Iteration Process**
   - Quick prototypes for validation
   - Regular feedback cycles
   - Documentation of decisions

3. **Knowledge Transfer**
   - Explanation of technical concepts
   - Best practices sharing
   - Pattern recognition
   - Learning opportunities

### 5.4 Decision Documentation

1. **Decision Record Format**
   - Context
   - Problem statement
   - Considered alternatives
   - Chosen solution
   - Implementation notes

2. **Future Reference**
   - Impact on future development
   - Related decisions
   - Lessons learned
   - Potential revisit points

### 5.5 Flexibility Points
- Architecture can evolve based on needs
- Implementation details can be adjusted
- Feature priorities can be reordered
