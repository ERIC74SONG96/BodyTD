---
description: 
globs: 
alwaysApply: true
---
---
description: 
globs: 
alwaysApply: true
---
 ---
description: BodyTD - A Biological Tower Defense Game
globs: ["**/*.kt"]
alwaysApply: false
---

# BodyTD Game Specifications

## 1. Game Overview
BodyTD is a tower defense game with a biological theme where players defend against various pathogens using different types of defensive towers.

## 2. Core Game Mechanics (example)

### 2.1 Towers
- **Base Tower Class**: Abstract `Turret` class with:
  - Cost: Int
  - Range: Int (default 3)
  - Attack Strategy: AttackStrategy interface
  - Abstract methods: attackEnemy()

- **Tower Types**:
  1. **Mucus Tower**
     - Cost: 10
     - Effect: Slows enemies and light damage
     - Range: 3
     - Strategy: SlowEffectAttack and SingleTargetAttack

  2. **Macrophage Tower**
     - Cost: 20
     - Effect: Heavy damage
     - Range: 3
     - Strategy: SingleTargetAttack

  3. **Cough Tower**
     - Cost: 10
     - Effect: Push back enemies
     - Range: 3
     - Strategy: PushBackAttack

### 2.2 Enemies
- **Base Enemy Class**: Abstract class with:
  - Health: Int
  - Speed: Float
  - Reward: Int
  - Position: Int

- **Enemy Types**:
  1. **Virus**
     - Health: 50
     - Speed: 3.0
     - Reward: 10

  2. **Bacteria**
     - Health: 100
     - Speed: 1.0
     - Reward: 20

  3. **Fine Particle**
     - Health: 30
     - Speed: 1.0
     - Reward: 5

### 2.3 Game Flow
- Waves of enemies spawn at regular intervals
- Players earn money by defeating enemies
- Money can be used to:
  - Place new towers
- Game ends if 3 enemies reach the end as a loss or as a win after the third wave

## 3. Technical Architecture

### 3.1 Design Patterns
1. **Strategy Pattern**
   - Used for tower attack behaviors
   - Implemented via AttackStrategy interface

2. **Factory Pattern**
   - EnemyFactory for creating different enemy types
   - Centralized enemy creation logic

3. **Singleton Pattern**
   - GameManager for global game state
   - WaveManager for wave control

4. **Observer Pattern**
   - For game events and state changes
   - Used in HUD updates (when Jetpack Compose isn't better or enough)

### 3.2 UI Implementation
- Uses Jetpack Compose for modern UI
- GameView for rendering game elements
- HUD for displaying game information
- Responsive layout with proper scaling

### 3.3 File Structure

Per [bodytd_file_structure.mdc](mdc:.cursor/rules/bodytd_file_structure.mdc)

## 4. Development Guidelines

### 4.1 Code Style
- Follow Kotlin coding conventions
- Use meaningful variable and function names
- Keep functions focused and single-purpose

### 4.2 Performance Considerations
- Memory management for game objects

## 5. Future Enhancements
- Additional tower types
- New enemy varieties
- Power-ups and special abilities
- Multiple maps and difficulty levels
- Achievement system
- Sound effects and background music
